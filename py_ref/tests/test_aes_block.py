#
#   MIT License
#
#   Copyright (c) 2024, Mattias Aabmets
#
#   The contents of this file are subject to the terms and conditions defined in the License.
#   You may not use, modify, or distribute this file except in compliance with the License.
#
#   SPDX-License-Identifier: MIT
#
import pytest
from src.aes_sbox import SBox
from src.aes_block import AESBlock
from src.blake_keygen import BlakeKeyGen


@pytest.fixture(name="aes_block", scope="function")
def fixture_internal_state() -> AESBlock:
	keygen = BlakeKeyGen(b'', b'', b'')
	data = [
		0x87, 0xF2, 0x4D, 0x97,
		0x6E, 0x4C, 0x90, 0xEC,
		0x46, 0xE7, 0x4A, 0xC3,
		0xA6, 0x8C, 0xD8, 0x95,
	]
	return AESBlock(keygen, data, counter=0)


def test_aes_block_init():
	keygen = BlakeKeyGen(b'', b'', b'')
	block = AESBlock(keygen, [0] * 16, counter=0)
	for uint8 in block.vector:
		assert uint8.value == 0

	assert len(block.keys) == 11
	for key_set in block.keys:
		assert len(key_set) == 16


def test_aes_block_encrypt_decrypt(aes_block):
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0x87, 0xF2, 0x4D, 0x97,
		0x6E, 0x4C, 0x90, 0xEC,
		0x46, 0xE7, 0x4A, 0xC3,
		0xA6, 0x8C, 0xD8, 0x95,
	]
	aes_block.encrypt_block()
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0xCD, 0x1C, 0x8C, 0x33,
		0xDE, 0xB9, 0x19, 0xA7,
		0x19, 0x20, 0x0A, 0x8B,
		0xD6, 0xCB, 0xB2, 0x58,
	]
	aes_block.decrypt_block()
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0x87, 0xF2, 0x4D, 0x97,
		0x6E, 0x4C, 0x90, 0xEC,
		0x46, 0xE7, 0x4A, 0xC3,
		0xA6, 0x8C, 0xD8, 0x95,
	]


def test_aes_block_mix_columns(aes_block):
	aes_block.mix_columns()
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0xC2, 0x38, 0x4D, 0x18,
		0x74, 0xB1, 0x36, 0xAD,
		0x37, 0x8E, 0x6B, 0xFA,
		0x95, 0x43, 0x25, 0x94
	]
	aes_block.inv_mix_columns()
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0x87, 0xF2, 0x4D, 0x97,
		0x6E, 0x4C, 0x90, 0xEC,
		0x46, 0xE7, 0x4A, 0xC3,
		0xA6, 0x8C, 0xD8, 0x95,
	]


def test_aes_block_shift_rows(aes_block):
	aes_block.shift_rows()
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0x87, 0x4C, 0x4A, 0x95,
		0x6E, 0xE7, 0xD8, 0x97,
		0x46, 0x8C, 0x4D, 0xEC,
		0xA6, 0xF2, 0x90, 0xC3,
	]
	aes_block.inv_shift_rows()
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0x87, 0xF2, 0x4D, 0x97,
		0x6E, 0x4C, 0x90, 0xEC,
		0x46, 0xE7, 0x4A, 0xC3,
		0xA6, 0x8C, 0xD8, 0x95,
	]


def test_aes_block_add_round_key(aes_block):
	aes_block.add_round_key(0)
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0xB4, 0xB0, 0xF7, 0x49,
		0x0A, 0x2D, 0xA1, 0x0D,
		0xE6, 0xFB, 0x8D, 0x46,
		0x11, 0xBE, 0xC0, 0x9E,
	]
	aes_block.add_round_key(0)
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0x87, 0xF2, 0x4D, 0x97,
		0x6E, 0x4C, 0x90, 0xEC,
		0x46, 0xE7, 0x4A, 0xC3,
		0xA6, 0x8C, 0xD8, 0x95,
	]


def test_aes_block_sub_bytes(aes_block):
	aes_block.sub_bytes(SBox.ENC)
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0x17, 0x89, 0xE3, 0x88,
		0x9F, 0x29, 0x60, 0xCE,
		0x5A, 0x94, 0xD6, 0x2E,
		0x24, 0x64, 0x61, 0x2A
	]
	aes_block.sub_bytes(SBox.DEC)
	values = [obj.value for obj in aes_block.vector]
	assert values == [
		0x87, 0xF2, 0x4D, 0x97,
		0x6E, 0x4C, 0x90, 0xEC,
		0x46, 0xE7, 0x4A, 0xC3,
		0xA6, 0x8C, 0xD8, 0x95,
	]
